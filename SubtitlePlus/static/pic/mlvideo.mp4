import random
from random import randint
from random import sample
import numpy as np
import signal, datetime
import argparse
import copy
import json
import heapq
from collections import defaultdict

class TimeoutException(Exception):
    pass

def handle_maxSeconds(signum, frame):
    raise TimeoutException()

VERBOSE=True

# return True if clause has a true literal
def check_clause(clause, assignment):
    # print('checking clause {} against assignment {}'.format(clause,assignment))
    clause_val = False
    for i in clause:
        if np.sign(i)==np.sign(assignment[abs(i)-1]): #assignment is 0-ref, variables 1-ref
                clause_val=True
    # print('--check came out {}'.format(clause_val))
    return clause_val

def check(clauses,assignment):
    global VERBOSE
    
    if VERBOSE:
        print('Checking assignment {}'.format(assignment))
        print('score of assignment is {}'.format(score(clauses,assignment)))
    for clause in clauses:
        if not check_clause(clause, assignment):
            return clause
    print('Check succeeded!')
    return True
       
def backtrack_search (num_variables, clauses):
    print('Backtracking search started')

    def backtrack(assignment,i):
        # i is next variable number to try values for (1..numvariables)
        if i==num_variables+1:  # no more variables to try
            if check(clauses,assignment)==True:
                return assignment
            return None
        else:
            for val in [-1,1]:
                assignment[i-1]=val  # assignment is 0-ref, so assignment[x] stores variable x+1 value
                result=backtrack(assignment,i+1)
                if result != None:
                    return result
        return None

    assignment = np.array([1]*num_variables)
    result=backtrack(assignment,1)
    print('Backtracking search completed successfully')
    return(result)

def flip_within_false_clause(num_variables, clauses):
    print('Flip within false clause search started')
#   clauses = simplify_clauses(num_variables, clauses)
    assignment = np.array([1]*num_variables)
    k=len(clauses[0])
    steps = 0
    while True:
        steps += 1
        false_clause = check(clauses,assignment)
        if false_clause==True:
            break
        literal = false_clause[randint(0,k-1)]
        assignment[abs(literal)-1] = np.sign(literal)
    print('Flip within false clause search completed successfully')
    return assignment

def random_walk(num_variables, clauses):
    print('Random walk search started')
    assignment = np.ones(num_variables)
    while True:
        if True==check(clauses,assignment):
            break
        var_to_flip=randint(1,num_variables)
        assignment[var_to_flip-1] *= -1
    print('Random walk search completed successfully')
    return assignment

# too slow
def hill_climbing_all_flips(num_variables, clauses):
    global VERBOSE
    lateral_limit = 25
    step_limit = 30*num_variables
    init_tries = 1000

    def flip(assignment,var):
        assignment[var-1] *= -1
        return assignment

    def flip_score(assignment, var):
        assignment[var-1] *= -1
        val = score(clauses, assignment)
        assignment[var-1] *= -1
        return val

    print('Hill climbing search started')
    
    current_score = 1 #anything > 0
    while current_score > 0:
        assignments = [np.array([2*randint(0,1)-1 for _ in range(num_variables)]) for _ in range(init_tries)]
        scored_assignments = [(score(clauses,a),a) for a in assignments]
        if VERBOSE:
            print('initial assignment scores were {}'.format([s for (s,a) in scored_assignments]))
        
        (current_score,assignment) = min(scored_assignments, key=lambda x:x[0])

        lateral_steps = 0
        all_neighbors_worse = False
        steps = 0
        end_this_try = False
        
        while not end_this_try:
            if VERBOSE:
                print('Score is {}, lateral_steps is {}'.format(current_score,lateral_steps))
                if lateral_steps>0:
                    print('Assignment is {}'.format(assignment))
            (candidate_score,candidate) = min([(flip_score(assignment,i+1), i+1)
                                               for i in range(num_variables)])
            if candidate_score <= current_score:
                if candidate_score == current_score:
                    lateral_steps += 1
                else:
                    lateral_steps = 0
                    current_score = candidate_score
                flip(assignment,candidate)
            else:
                all_neighbors_worse = True

            end_this_try = False
            end_this_try = end_this_try or (current_score == 0)
            end_this_try = end_this_try or all_neighbors_worse
            end_this_try = end_this_try or lateral_steps >= lateral_limit
            end_this_try = end_this_try or steps >= step_limit

    if check(clauses,assignment)==True:
        print('Hill climbing completed successfully')
    else:
        print('Hill climbing found local optimum')
    return assignment


# better but still too slow
def hill_climbing_one_clause(num_variables, clauses):
    global VERBOSE
    lateral_limit = num_variables / 2
    step_limit = 30*num_variables
    init_tries = 10

    def flip(assignment,var):
        assignment[var-1] *= -1
        return assignment

    def flip_score(assignment, var):
        assignment[var-1] *= -1
        (val,clause_index) = score_with_info(clauses, assignment)
        assignment[var-1] *= -1
        return (val,clause_index)

    print('Hill climbing (one clause) search started')
    
    current_score = 1 #anything > 0
    while current_score > 0:
        assignments = []
        for i in range(init_tries):
            new_assignment = np.arange(num_variables)
            for loc in range(num_variables):
                new_assignment[loc] = 2*randint(0,1)-1
            assignments.append(new_assignment)
        # assignments = [np.array([2*randint(0,1)-1 for _ in range(num_variables)])
        #                for _ in range(init_tries)]
        scored_assignments = [(score(clauses,a),a) for a in assignments]
        if VERBOSE:
            print('initial assignment scores were {}'.format([s for (s,a) in scored_assignments]))
        
        (current_score,assignment) = min(scored_assignments, key=lambda x: x[0])
        (_, false_clause) = score_with_info(clauses, assignment)

        lateral_steps = 0
        all_neighbors_worse = False
        steps = 0
        end_this_try = (current_score == 0)
        
        while not end_this_try:
            if VERBOSE:
                print('Score is {}, lateral_steps is {}'.format(current_score,lateral_steps))
            clause = clauses[false_clause]
            ((candidate_score, false_clause), candidate) = min([(flip_score(assignment,abs(literal)),
                                                                 abs(literal)) 
                                                                for literal in clause])
            
            # ((candidate_score, false_clause), candidate) = min([(val, new_false_clause, candidate)
            #                                                   for ((val, new_false_clause),var_to_flip)
            #                                                   in scores_with_info])

            if candidate_score <= current_score:
                if candidate_score == current_score:
                    lateral_steps += 1
                else:
                    lateral_steps = 0
                    current_score = candidate_score
                flip(assignment,candidate)
            else:
                all_neighbors_worse = True

            end_this_try = False
            end_this_try = end_this_try or (current_score == 0)
            end_this_try = end_this_try or all_neighbors_worse
            end_this_try = end_this_try or lateral_steps >= lateral_limit
            end_this_try = end_this_try or steps >= step_limit

    if check(clauses,assignment)==True:
        print('Hill climbing completed successfully')
    else:
        print('Hill climbing found local optimum')
    return assignment

def score(clauses,assignment):
    return sum(map(lambda c : 0 if check_clause(c,assignment) else 1, 
                   clauses))

def score_with_info(clauses,assignment):
    clause_vals = [0 if check_clause(c,assignment) else 1 for c in clauses]
    val = sum(clause_vals)
    info = clause_vals.index(1) if val>0 else 0
    return (val,info)

def tabu_beam_search(num_variables, clauses, use_beam):
    global VERBOSE

    tabu_max = round(num_variables / 100)*round(num_variables / 100)*100 #1000
    beam_width = 7
                  
    if use_beam:
        print('Tabu beam search started with beam width {}'.format(beam_width))
    else:
        print('Tabu search started')
    k = len(clauses[0])
    assignment = [1 for _ in range(num_variables)]#np.ones(num_variables)
    tabulist = []
    count1 = -1
    maxed = False
    while True:
        false_clause = check(clauses,assignment)
        if false_clause==True: # found a solution
            break
        
        # with tabu search
        scorelist = [] # the smaller the better
        for i in range(k):
            literal = false_clause[i]
            record = assignment[abs(literal)-1]
            assignment[abs(literal)-1] = np.sign(literal)

            literal_score = score(clauses,assignment)
            
            if (assignment not in tabulist):#(not any(map(lambda x: x is assignment, tabulist))): 
                tabulist.append(assignment)
                if maxed:
                    tabulist.pop(0)
                elif len(tabulist) >= tabu_max:
                    maxed = True
                    tabulist.pop(0)                   
                assignment = assignment.copy()
            else:
                literal_score += 100
            scorelist.append(literal_score)
            assignment[abs(literal)-1] = record # change it back

        selection = scorelist.index(min(scorelist))
        literal = false_clause[selection]
        assignment[abs(literal)-1] = np.sign(literal)
        count1 += 1

        if count1%100 == 0:
            val = score(clauses, assignment)
            if VERBOSE:
                print("score:{},count1:{}".format(val,assignment),count1)
            if use_beam and val < 0.1*num_variables:
                assignment = tabu_beam_active(num_variables, clauses, 
                                              assignment, tabulist, beam_width)
                break
    print('Tabu search completed successfully')
    return assignment

def tabu_beam_active(num_variables,clauses,assignment,tabulist,beam_width):

    tabu_max = round(num_variables / 100)*round(num_variables / 100)*100 #1000

    count1 = -1
    beam = [assignment]
    for i in range(beam_width-1):
        beam.append([2*randint(0,1)-1 for _ in range(num_variables)])
    maxed=False
    while True:
        ## 1 do greedy, check all one-step possibilities from beam
        scorelist = [] # the smaller the better
        assignment_list = []
        for i1 in range(beam_width):
            assignment = beam[i1] 
            false_clause = check(clauses,assignment)
            if false_clause==True: # found a solution
                return assignment
            # with tabu search
            for i in range(3):
                literal = false_clause[i]
                assignment0 = assignment.copy()
                assignment0[abs(literal)-1] = np.sign(literal) # change
                fail_num = score(clauses,assignment0)
                if assignment0 not in tabulist:
                    tabulist.append(assignment0.copy())
                    if maxed:
                        tabulist.pop(0)
                    elif len(tabulist) >= tabu_max:
                        maxed = True
                        tabulist.pop(0)                   
                else:
                    fail_num += num_variables # so you don't go back
                scorelist.append([fail_num,i1*3+i])
                assignment_list.append(assignment0)
        newscoreList = sorted(scorelist)
        # selection1 = newscoreList[0][1] # first choice
        # selection2 = newscoreList[1][1] # second choice
        # selection3 = newscoreList[2][1]
        # beam = [assignment_list[selection1], assignment_list[selection2], assignment_list[selection3]]

        beam=[]
        for i in range(beam_width):
            beam.append(assignment_list[newscoreList[i][1]])

        count1 += 1
        if (count1%100 == 0):
            print("score0 is {}, score1 is {}, score2 is {}, count1 is {}".format(score(clauses,beam[0]),score(clauses,beam[1]),score(clauses,beam[2]),count1))

# #
# bfs_search to find the next level of assignment 
# #
def enforced_hill_climbing(num_variables,clauses):
    print('Enforced hill climbing search started')
    assignment = np.array([randint(0,1)*2-1 for _ in range(num_variables)])
    current_score = score(clauses,assignment)
    while current_score > 0:
        (current_score, assignment) = best_first_search(assignment, current_score, num_variables, clauses)
    print('Enforced hill climbing search finished successfully')
    return assignment

def assign_hash(assignment):
    u = assignment.view('u' + str(assignment.itemsize))
    return np.bitwise_xor.reduce(u.ravel())

def default_value_fun():
    return []

def best_first_search(assignment, target_score, num_variables, clauses):
    print('target score is {}'.format(target_score))
    false_clause = check(clauses, assignment)
    time = 0 # tie breaking for heapq
    pqueue=[(target_score, time, (assignment, false_clause))]
    heapq.heapify(pqueue)
    seen = defaultdict(default_value_fun)
    seen[assign_hash(assignment)].insert(0,assignment)
    while True:
        (focus_score, _, (focus, false_clause)) = heapq.heappop(pqueue)
        # print('focusing on {} at score {}'.format(focus,focus_score))
        for i in range(3):  # 3-SAT
            literal = false_clause[i]
            child = np.copy(focus)
            child[abs(literal)-1] = np.sign(literal)
            (child_score, false_clause_index) = score_with_info(clauses,child)
            # print('adding child {} at score {} and false clause {}'.format(child, child_score, clauses[false_clause_index]))

            if child_score < target_score:
                return (child_score, child)

            time += 1
            if not any(np.array_equal(child, x) for x in seen[assign_hash(child)]):
                seen[assign_hash(child)].insert(0,child)
                heapq.heappush(pqueue,(child_score, time, (child,clauses[false_clause_index])))

def generate_solvable_problem(num_variables): 
    global VERBOSE
    
    random.seed()
    k=3 # 3-SAT
    
    clauses_per_variable = 4.2  # < 4.2 easy;  >4.2 usually unsolvable.  4.2 challenging to determine.
    num_clauses=round(clauses_per_variable*num_variables)

    # this assignment must solve the problem
    target = np.array([2*randint(0,1)-1 for _ in range(num_variables)]) 
    clauses=[]
    for i in range(num_clauses):
        seeking = True
        while seeking:
            clause=sorted((sample(range(0,num_variables),k))) # choose k variables at random 
            clause=[i+1 for i in clause]
            clause=[(2*randint(0,1)-1)*clause[x] for x in range(k)] # choose their signs at random
            seeking = not check_clause(clause,target)
        clauses.append(clause)

    if VERBOSE:
        print('Problem is {}'.format(clauses))
        print('One solution is {} which checks to {}'.format(target,check(clauses,target)))
        
    return clauses


# #
# bfs_search to find the next level of assignment 
# #
def ben_bfs_search(num_variables, clauses, assignment, tabulist, false_clause):
    possible_states=[assignment]
    scoreToBeat = score(clauses,assignment)
    while True:
        scorelist = []
        # new_states will be the possible_states in the next run
        new_states = []
        # possible_states serves as the action list / potential
        # new states for bfs expansion
        for currState in possible_states:
            for i in range(3):
                # mostly the same as tabu
                literal = false_clause[i]
                record = currState[abs(literal)-1]
                # generate next 'state' which is a candidate for the next assignment
                newState = copy.deepcopy(currState)
                newState[abs(literal)-1] = np.sign(literal)
                fail_num = score(clauses,newState)

                # always append to newStates so that index matches scorelist
                new_states.append(newState)
                # instead of maintaining a queue like regular bfs, we keep the tabulist idea
                if newState not in tabulist:
                    tabulist.append(newState)
                else:
                    fail_num += 100
                # score_list can have more than 3 elements. It can have up to 3^n elements 
                # where n is the number of times that the option is expanded in bfs
                scorelist.append(fail_num)

        selection = scorelist.index(min(scorelist))
        # print(scorelist[selection],scoreToBeat)
        if scorelist[selection] <= scoreToBeat:
            # found a better state!!!
            return new_states[selection], tabulist
        # new states are what we will consider next
        possible_states = new_states

def ben_stochastic_search(num_variables, clauses):
    print('Ben enforced hill climbing started')
    assignment = [1 for _ in range(num_variables)]
    tabulist = []
    while True:
        false_clause = check(clauses,assignment)
        if false_clause==True:
            print('Ben enforced hill climbing successfully finished')
            return assignment
        # replace assignment with the optimal assignment from the bfs search
        assignment, tabulist = ben_bfs_search(num_variables, clauses, assignment,tabulist, false_clause)
        if len(tabulist) >= 1000:
            tabulist.pop(0)

def hw7_submission(num_variables, clauses):
    raise(Exception('NotImplemented'))

def solve_SAT(file,save,timeout,num_variables,algorithms,verbose):
    global VERBOSE
    
    VERBOSE=verbose

    if file != None:
        with open(file,"r") as f:
            [num_variables,timeout,clauses] = json.load(f)
        print('Problem with {} variables and timeout {} seconds loaded'.format(num_variables,timeout))
    else:
        clauses = generate_solvable_problem(num_variables)
        if timeout==None:
            timeout = round(60 * num_variables / 100)
        print('Problem with {} variables generated, timeout is {}'.format(num_variables,timeout))

    if save != None:
        with open(save,"w") as f:
            json.dump((num_variables,timeout,clauses),f)

    if 'project7_submission' in algorithms:
        signal.signal(signal.SIGALRM, handle_maxSeconds)
        signal.alarm(timeout)
        startTime = datetime.datetime.now()
        try:
            result="Timeout"
            result=project7_submission(num_variables,clauses)
            print('Solution found is {}'.format(result))
            if not (True == check(clauses,result)):
                print('Returned assignment incorrect')
        except TimeoutException:
            print("Timeout!")
        endTime = datetime.datetime.now()
        seconds_used = (endTime - startTime).seconds
        signal.alarm(0)
        print('Search returned in {} seconds\n'.format(seconds_used))
    if 'tabu' in algorithms:
        signal.signal(signal.SIGALRM, handle_maxSeconds)
        signal.alarm(timeout)
        startTime = datetime.datetime.now()
        try:
            result="Timeout"
            result=tabu_beam_search(num_variables,clauses,False)
            print('Solution found is {}'.format(result))
            if not (True == check(clauses,result)):
                print('Returned assignment incorrect')
        except TimeoutException:
            print("Timeout!")
        endTime = datetime.datetime.now()
        seconds_used = (endTime - startTime).seconds
        signal.alarm(0)
        print('Search returned in {} seconds\n'.format(seconds_used))
    if 'tabu_beam' in algorithms:
        signal.signal(signal.SIGALRM, handle_maxSeconds)
        signal.alarm(timeout)
        startTime = datetime.datetime.now()
        try:
            result="Timeout"
            result=tabu_beam_search(num_variables,clauses,True)
            print('Solution found is {}'.format(result))
            if not (True == check(clauses,result)):
                print('Returned assignment incorrect')
        except TimeoutException:
            print("Timeout!")
        endTime = datetime.datetime.now()
        seconds_used = (endTime - startTime).seconds
        signal.alarm(0)
        print('Search returned in {} seconds\n'.format(seconds_used))
    if 'backtrack' in algorithms:
        signal.signal(signal.SIGALRM, handle_maxSeconds)
        signal.alarm(timeout)
        startTime = datetime.datetime.now()
        try:
            result="Timeout"
            result=backtrack_search(num_variables,clauses)
            print('Solution found is {}'.format(result))
            if not (True == check(clauses,result)):
                print('Returned assignment incorrect')
        except TimeoutException:
            print("Timeout!")
        endTime = datetime.datetime.now()
        seconds_used = (endTime - startTime).seconds
        signal.alarm(0)
        print('Search returned in {} seconds\n'.format(seconds_used))
    if 'random_walk' in algorithms:
        signal.signal(signal.SIGALRM, handle_maxSeconds)
        signal.alarm(timeout)
        startTime = datetime.datetime.now()
        try:
            result="Timeout"
            result=random_walk(num_variables,clauses)
            print('Solution found is {}'.format(result))
            if not (True == check(clauses,result)):
                print('Returned assignment incorrect')
        except TimeoutException:
            print("Timeout!")
        endTime = datetime.datetime.now()
        seconds_used = (endTime - startTime).seconds
        signal.alarm(0)
        print('Search returned in {} seconds\n'.format(seconds_used))
    if 'enforced_hc' in algorithms:
        signal.signal(signal.SIGALRM, handle_maxSeconds)
        signal.alarm(timeout)
        startTime = datetime.datetime.now()
        try:
            result="Timeout"
            result=enforced_hill_climbing(num_variables,clauses)
            print('Solution found is {}'.format(result))
            if not (True == check(clauses,result)):
                print('Returned assignment incorrect')
        except TimeoutException:
            print("Timeout!")
        endTime = datetime.datetime.now()
        seconds_used = (endTime - startTime).seconds
        signal.alarm(0)
        print('Search returned in {} seconds\n'.format(seconds_used))
    if 'ben_bfs' in algorithms:
        signal.signal(signal.SIGALRM, handle_maxSeconds)
        signal.alarm(timeout)
        startTime = datetime.datetime.now()
        try:
            result="Timeout"
            result=ben_stochastic_search(num_variables,clauses)
            print('Solution found is {}'.format(result))
            if not (True == check(clauses,result)):
                print('Returned assignment incorrect')
        except TimeoutException:
            print("Timeout!")
        endTime = datetime.datetime.now()
        seconds_used = (endTime - startTime).seconds
        signal.alarm(0)
        print('Search returned in {} seconds\n'.format(seconds_used))
    if 'flip_within_false_clause' in algorithms:
        signal.signal(signal.SIGALRM, handle_maxSeconds)
        signal.alarm(timeout)
        startTime = datetime.datetime.now()
        try:
            result="Timeout"
            result=flip_within_false_clause(num_variables,clauses)
            print('Solution found is {}'.format(result))
            if not (True == check(clauses,result)):
                print('Returned assignment incorrect')
        except TimeoutException:
            print("Timeout!")
        endTime = datetime.datetime.now()
        seconds_used = (endTime - startTime).seconds
        signal.alarm(0)
        print('Search returned in {} seconds\n'.format(seconds_used))
    if 'hill_climb_af' in algorithms:
        signal.signal(signal.SIGALRM, handle_maxSeconds)
        signal.alarm(timeout)
        startTime = datetime.datetime.now()
        result="Timeout"
        try:
            result=hill_climbing_all_flips(num_variables,clauses)
            print('Solution found is {}'.format(result))
            if not (True == check(clauses,result)):
                print('Returned assignment incorrect')
        except TimeoutException:
            print("Timeout!")
        endTime = datetime.datetime.now()
        seconds_used = (endTime - startTime).seconds
        signal.alarm(0)
        print('Search returned in {} seconds\n'.format(seconds_used))
    if 'hill_climb_1c' in algorithms:
        signal.signal(signal.SIGALRM, handle_maxSeconds)
        signal.alarm(timeout)
        startTime = datetime.datetime.now()
        result="Timeout"
        try:
            result=hill_climbing_one_clause(num_variables,clauses)
            print('Solution found is {}'.format(result))
            if not (True == check(clauses,result)):
                print('Returned assignment incorrect')
        except TimeoutException:
            print("Timeout!")
        endTime = datetime.datetime.now()
        seconds_used = (endTime - startTime).seconds
        signal.alarm(0)
        print('Search returned in {} seconds\n'.format(seconds_used))

def main():
    default_numvars = 200
    default_timeout = 30

    parser = argparse.ArgumentParser(description="Run stochastic search on a 3-SAT problem")
    parser.add_argument("algorithms", nargs='*',
                        help="Algorithms to try",
                        choices=['random_walk', 'enforced_hc', 'project7_submission','flip_within_false_clause', 'backtrack' , 'hill_climb_1c' , 'hill_climb_af' , 'tabu', 'tabu_beam', 'ben_bfs'])
    parser.add_argument("-f", "--file", help="file name with 3-SAT formula to use", default=None)
    parser.add_argument("-s", "--save", help="file name to save problem in", default=None)
    parser.add_argument("-t", "--timeout", help="Seconds to allow (default based on # of vars)", type=int, default=None)
    parser.add_argument("-n", "--numvars", help="Number of variables (default 20)", type=int, default=20)
    parser.add_argument("-v", "--verbose", help="Whether to print tracing information", action="store_true")
    
    args = parser.parse_args()
    file = args.file
    save = args.save
    timeout = args.timeout
    num_variables = args.numvars 
    algorithms = args.algorithms
    verbose = args.verbose

    if (file!=None and (timeout != None or num_variables != None)):
        print('\nUsing input file, any command line parameters for number of variables and timeout will be ignored\n')
    solve_SAT(file,save,timeout,num_variables,algorithms,verbose)

if __name__ == '__main__':
    main()



# if you prefer to load the file rather than use command line
# parameters, use this section to configure the solver
#
# outfile = 'last.txt' # 'foo.txt'
# infile = None # 'last.txt' # 'save500.txt'
# timeout = None #ignored if infile is present, will be set based on numvars if None here
# numvars = 500 #ignored if infile is present
# algorithms = ['tabu_beam', 'enforced_hc']
# verbosity = False
# solve_SAT(infile, outfile, timeout, numvars, algorithms, verbosity)
